<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PodamUtils.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">podam</a> &gt; <a href="index.source.html" class="el_package">uk.co.jemos.podam.api</a> &gt; <span class="el_source">PodamUtils.java</span></div><h1>PodamUtils.java</h1><pre class="source lang-java linenums">/**
 *
 */
package uk.co.jemos.podam.api;


import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import uk.co.jemos.podam.common.PodamExclude;

import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.*;

/**
 * PODAM Utilities class.
 *
 * @author mtedone
 *
 * @since 1.0.0
 *
 */
public final class PodamUtils {

	// ----------------------&gt;&gt; Constants

	private static final int SETTER_IDENTIFIER_LENGTH = 3;

	private static final String GETTER_PREFIX = &quot;get&quot;;
	private static final String GETTER_PREFIX2 = &quot;is&quot;;

	/** An array of valid String characters */
<span class="fc" id="L35">	public static final char[] NICE_ASCII_CHARACTERS = new char[] { 'a', 'b',</span>
			'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
			'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B',
			'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
			'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1',
			'2', '3', '4', '5', '6', '7', '8', '9', '_' };

	/** The application logger. */
<span class="fc" id="L43">	private static final Logger LOG = LogManager.getLogger(PodamUtils.class);</span>

	/** Non instantiable constructor */
<span class="nc" id="L46">	private PodamUtils() {</span>
<span class="nc" id="L47">		throw new AssertionError();</span>
	}

	/**
	 * It returns a {@link ClassInfo} object for the given class
	 *
	 * @param clazz
	 *            The class to retrieve info from
	 * @param attributeApprover
	 *            a {@link ClassAttributeApprover} implementation,
	 *             which attributes to skip and which to process.
	 *             If one hasn't been provided, Podam will use the
	 *             default one in the {@link DefaultClassInfoStrategy} class.
	 * @return a {@link ClassInfo} object for the given class
	 */
	public static ClassInfo getClassInfo(Class&lt;?&gt; clazz,
			ClassAttributeApprover attributeApprover) {

<span class="fc" id="L65">		return getClassInfo(clazz,</span>
				new HashSet&lt;Class&lt;? extends Annotation&gt;&gt;(),
<span class="fc" id="L67">				Collections.&lt;String&gt;emptySet(),</span>
				attributeApprover);
	}

	/**
	 * It returns a {@link ClassInfo} object for the given class
	 *
	 * @param clazz
	 *            The class to retrieve info from
	 * @param excludeFieldAnnotations
	 *            the fields marked with any of these annotations will not be
	 *            included in the class info
	 * @param excludedFields
	 *            the fields matching the given names will not be included in the class info
	 * @param attributeApprover
	 *            a {@link ClassAttributeApprover} implementation,
	 *             which defines which attributes to skip and which to process
	 * @return a {@link ClassInfo} object for the given class
	 */
	public static ClassInfo getClassInfo(Class&lt;?&gt; clazz,
			Set&lt;Class&lt;? extends Annotation&gt;&gt; excludeFieldAnnotations,
			Set&lt;String&gt; excludedFields,
			ClassAttributeApprover attributeApprover) {


<span class="fc" id="L92">		return getClassInfo(clazz, excludeFieldAnnotations, excludedFields, attributeApprover, Collections.&lt;Method&gt;emptySet());</span>

	}


	public static ClassInfo getClassInfo(Class&lt;?&gt; clazz,
										 Set&lt;Class&lt;? extends Annotation&gt;&gt; excludeFieldAnnotations,
										 Set&lt;String&gt; excludedFields,
										 ClassAttributeApprover attributeApprover,
										 Collection&lt;Method&gt; extraMethods) {

<span class="fc bfc" id="L103" title="All 2 branches covered.">		if (null == attributeApprover) {</span>
<span class="fc" id="L104">			attributeApprover = DefaultClassInfoStrategy.getInstance().getClassAttributeApprover(clazz);</span>
		}

<span class="fc" id="L107">		Set&lt;Field&gt; classFields = new HashSet&lt;Field&gt;();</span>
<span class="fc" id="L108">		Set&lt;Method&gt; classGetters = new HashSet&lt;Method&gt;();</span>
<span class="fc" id="L109">		Set&lt;Method&gt; classSetters = new HashSet&lt;Method&gt;();</span>
<span class="fc" id="L110">		fillPojoSets(clazz, classFields, classGetters, classSetters, excludeFieldAnnotations, excludedFields);</span>

<span class="fc" id="L112">		Map&lt;String, ClassAttribute&gt; map = new TreeMap&lt;String, ClassAttribute&gt;();</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">		for (Field classField : classFields) {</span>
<span class="fc" id="L114">			ClassAttribute attribute = new ClassAttribute(classField,</span>
<span class="fc" id="L115">					Collections.&lt;Method&gt;emptySet(), Collections.&lt;Method&gt;emptySet());</span>
<span class="fc" id="L116">			map.put(classField.getName(), attribute);</span>
<span class="fc" id="L117">		}</span>

<span class="fc bfc" id="L119" title="All 2 branches covered.">		for (Method classGetter : classGetters) {</span>
<span class="fc" id="L120">			String attributeName = extractFieldNameFromGetterMethod(classGetter);</span>
<span class="fc" id="L121">			ClassAttribute attribute = map.get(attributeName);</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">			if (attribute != null) {</span>
<span class="fc" id="L123">				attribute.getRawGetters().add(classGetter);</span>
			} else {
<span class="fc" id="L125">				attribute = new ClassAttribute(null,</span>
<span class="fc" id="L126">						Collections.singleton(classGetter),</span>
<span class="fc" id="L127">						Collections.&lt;Method&gt;emptySet());</span>
<span class="fc" id="L128">				map.put(attributeName, attribute);</span>
			}
<span class="fc" id="L130">		}</span>

<span class="fc bfc" id="L132" title="All 2 branches covered.">		for (Method classSetter : classSetters) {</span>
<span class="fc" id="L133">			String attributeName = extractFieldNameFromSetterMethod(classSetter);</span>
<span class="fc" id="L134">			ClassAttribute attribute = map.get(attributeName);</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">			if (attribute != null) {</span>
<span class="fc" id="L136">				attribute.getRawSetters().add(classSetter);</span>
			} else {
<span class="fc" id="L138">				attribute = new ClassAttribute(null,</span>
<span class="fc" id="L139">						Collections.&lt;Method&gt;emptySet(),</span>
<span class="fc" id="L140">						Collections.singleton(classSetter));</span>
<span class="fc" id="L141">				map.put(attributeName, attribute);</span>
			}
<span class="fc" id="L143">		}</span>

		/* Approve all found attributes */
<span class="fc" id="L146">		Collection&lt;ClassAttribute&gt; attributes = new ArrayList&lt;ClassAttribute&gt;(map.values());</span>
<span class="fc" id="L147">		Iterator&lt;ClassAttribute&gt; iter = attributes.iterator();</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">		main : while(iter.hasNext()) {</span>
<span class="fc" id="L149">			ClassAttribute attribute = iter.next();</span>

<span class="fc bfc" id="L151" title="All 2 branches covered.">			for (Method classGetter : attribute.getRawGetters()) {</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">				if (containsAnyAnnotation(classGetter, excludeFieldAnnotations)) {</span>
<span class="fc" id="L153">					iter.remove();</span>
<span class="fc" id="L154">					continue main;</span>
				}
<span class="fc" id="L156">			}</span>

<span class="fc bfc" id="L158" title="All 2 branches covered.">			for (Method classSetter : attribute.getRawSetters()) {</span>
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">				if (containsAnyAnnotation(classSetter, excludeFieldAnnotations)) {</span>
<span class="nc" id="L160">					iter.remove();</span>
<span class="nc" id="L161">					continue main;</span>
				}
<span class="fc" id="L163">			}</span>

<span class="fc" id="L165">			Field field = attribute.getAttribute();</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">			if (field != null &amp;&amp; (</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">					excludedFields.contains(field.getName())</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">					|| containsAnyAnnotation(field, excludeFieldAnnotations))) {</span>
<span class="fc" id="L169">				iter.remove();</span>
<span class="fc" id="L170">				continue;</span>
			}

<span class="fc bfc" id="L173" title="All 2 branches covered.">			if (!attributeApprover.approve(attribute)) {</span>
<span class="fc" id="L174">				iter.remove();</span>
			}
<span class="fc" id="L176">		}</span>

<span class="fc" id="L178">		return new ClassInfo(clazz, attributes, extraMethods);</span>
	}


	/**
	 * Checks if the given field has any one of the annotations
	 *
	 * @param field
	 *            the field to check for
	 * @param annotations
	 *            the set of annotations to look for in the field
	 * @return true if the field is marked with any of the given annotations
	 */
	public static boolean containsAnyAnnotation(Field field,
			Set&lt;Class&lt;? extends Annotation&gt;&gt; annotations) {
<span class="fc bfc" id="L193" title="All 2 branches covered.">		for (Class&lt;? extends Annotation&gt; annotation : annotations) {</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">			if (field.getAnnotation(annotation) != null) {</span>
<span class="fc" id="L195">				return true;</span>
			}
<span class="fc" id="L197">		}</span>
<span class="fc" id="L198">		return false;</span>
	}

	/**
	 * Checks if the given method has any one of the annotations
	 *
	 * @param method
	 *            the method to check for
	 * @param annotations
	 *            the set of annotations to look for in the field
	 * @return true if the field is marked with any of the given annotations
	 */
	private static boolean containsAnyAnnotation(Method method,
			Set&lt;Class&lt;? extends Annotation&gt;&gt; annotations) {

<span class="fc bfc" id="L213" title="All 2 branches covered.">		for (Class&lt;? extends Annotation&gt; annotation : annotations) {</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">			if (method.getAnnotation(annotation) != null) {</span>
<span class="fc" id="L215">				return true;</span>
			}
<span class="fc" id="L217">		}</span>
<span class="fc" id="L218">		return false;</span>
	}

	/**
	 * Given a class and a set of class declared fields it returns a Set of
	 * setters, getters and fields defined for this class
	 * &lt;p&gt;
	 * Anything present: setter, getter or field will be recorded as three
	 * independent sets available for future analysis
	 * &lt;/p&gt;
	 *
	 * @param clazz
	 *            The class to analyze for setters
	 * @param classFields
	 *            The {@link Set} which will be filled with class' fields
	 * @param classGetters
	 *            The {@link Set} which will be filled with class' getters
	 * @param classSetters
	 *            The {@link Set} which will be filled with class' setters
	 * @param excludeAnnotations
	 *            The {@link Set} containing annotations marking fields to be excluded
	 * @param excludedFields
	 *            The {@link Set} containing field names to be excluded
	 */
	public static void fillPojoSets(Class&lt;?&gt; clazz, Set&lt;Field&gt; classFields,
			Set&lt;Method&gt; classGetters, Set&lt;Method&gt; classSetters,
			Set&lt;Class&lt;? extends Annotation&gt;&gt; excludeAnnotations,
			Set&lt;String&gt; excludedFields) {

<span class="pc bpc" id="L247" title="1 of 2 branches missed.">		if (excludeAnnotations == null) {</span>
<span class="nc" id="L248">			excludeAnnotations = new HashSet&lt;Class&lt;? extends Annotation&gt;&gt;();</span>
		}
<span class="fc" id="L250">		excludeAnnotations.add(PodamExclude.class);</span>

<span class="fc" id="L252">		Class&lt;?&gt; workClass = clazz;</span>

<span class="fc bfc" id="L254" title="All 2 branches covered.">		while (workClass != null) {</span>

<span class="fc" id="L256">			Method[] declaredMethods = workClass.getDeclaredMethods();</span>

<span class="fc bfc" id="L258" title="All 2 branches covered.">			for (Method method : declaredMethods) {</span>
				/*
				 * Bridge methods are automatically generated by compiler to
				 * deal with type erasure and they are not type safe. That why
				 * they should be ignored
				 */
<span class="fc bfc" id="L264" title="All 4 branches covered.">				if (!method.isBridge() &amp;&amp; !Modifier.isNative(method.getModifiers())) {</span>

<span class="fc bfc" id="L266" title="All 2 branches covered.">					if (method.getName().startsWith(&quot;set&quot;)</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">							&amp;&amp; method.getReturnType().equals(void.class)) {</span>
<span class="fc" id="L268">						classSetters.add(method);</span>
<span class="fc bfc" id="L269" title="All 4 branches covered.">					} else if ((method.getName().startsWith(GETTER_PREFIX) || method.getName().startsWith(GETTER_PREFIX2)) &amp;&amp;</span>
<span class="pc bpc" id="L270" title="1 of 4 branches missed.">							method.getParameterTypes().length == 0 &amp;&amp; !method.getReturnType().equals(void.class)) {</span>
<span class="fc" id="L271">						classGetters.add(method);</span>
					}
				}
			}

<span class="fc" id="L276">			Field[] declaredFields = workClass.getDeclaredFields();</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">			for (Field field : declaredFields) {</span>
<span class="fc" id="L278">				int modifiers = field.getModifiers();</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">				if (!Modifier.isStatic(modifiers)) {</span>

<span class="fc" id="L281">					classFields.add(field);</span>
				}
			}

<span class="fc" id="L285">			workClass = workClass.getSuperclass();</span>
<span class="fc" id="L286">		}</span>
<span class="fc" id="L287">	}</span>

	/**
	 * Given a setter {@link Method}, it extracts the field name, according to
	 * JavaBean standards
	 * &lt;p&gt;
	 * This method, given a setter method, it returns the corresponding
	 * attribute name. For example: given setIntField the method would return
	 * intField. The correctness of the return value depends on the adherence to
	 * JavaBean standards.
	 * &lt;/p&gt;
	 *
	 * @param method
	 *            The setter method from which the field name is required
	 * @return The field name corresponding to the setter
	 */
	public static String extractFieldNameFromSetterMethod(Method method) {
<span class="fc" id="L304">		String candidateField = method.getName().substring(SETTER_IDENTIFIER_LENGTH);</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">		if (!&quot;&quot;.equals(candidateField)) {</span>
<span class="fc" id="L306">			candidateField = Character.toLowerCase(candidateField.charAt(0))</span>
<span class="fc" id="L307">					+ candidateField.substring(1);</span>
		} else {
<span class="fc" id="L309">			LOG.debug(&quot;Encountered method {}. This will be ignored.&quot;, method);</span>
		}

<span class="fc" id="L312">		return candidateField;</span>
	}

	/**
	 * Given a getter {@link Method}, it extracts the field name, according to
	 * JavaBean standards
	 * &lt;p&gt;
	 * This method, given a getter method, it returns the corresponding
	 * attribute name. For example: given getIntField the method would return
	 * intField; given isBoolField the method would return boolField. The
	 * correctness of the return value depends on the adherence to JavaBean
	 * standards.
	 * &lt;/p&gt;
	 *
	 * @param method
	 *            The setter method from which the field name is required
	 * @return The field name corresponding to the setter
	 */
	public static String extractFieldNameFromGetterMethod(Method method) {
<span class="fc" id="L331">		String candidateField = method.getName();</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">		if (candidateField.startsWith(GETTER_PREFIX)) {</span>
<span class="fc" id="L333">			candidateField = candidateField.substring(GETTER_PREFIX.length());</span>
<span class="pc bpc" id="L334" title="1 of 2 branches missed.">		} else if (candidateField.startsWith(GETTER_PREFIX2)) {</span>
<span class="fc" id="L335">			candidateField = candidateField.substring(GETTER_PREFIX2.length());</span>
		}
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">		if (!&quot;&quot;.equals(candidateField)) {</span>
<span class="fc" id="L338">			candidateField = Character.toLowerCase(candidateField.charAt(0))</span>
<span class="fc" id="L339">					+ candidateField.substring(1);</span>
		} else {
<span class="nc" id="L341">			LOG.debug(&quot;Encountered method {}. This will be ignored.&quot;, method);</span>
		}

<span class="fc" id="L344">		return candidateField;</span>
	}

	/**
	 * It returns a {@link Field} matching the attribute name or null if a field
	 * was not found.
	 *
	 * @param pojoClass
	 *            The class supposed to contain the field
	 * @param attributeName
	 *            The field name
	 *
	 * @return a {@link Field} matching the attribute name or null if a field
	 *         was not found.
	 */
	public static Field getField(Class&lt;?&gt; pojoClass, String attributeName) {

<span class="fc" id="L361">		Field field = null;</span>

<span class="fc" id="L363">		Class&lt;?&gt; clazz = pojoClass;</span>

<span class="fc bfc" id="L365" title="All 2 branches covered.">		while (clazz != null) {</span>
			try {
<span class="fc" id="L367">				field = clazz.getDeclaredField(attributeName);</span>
<span class="fc" id="L368">				break;</span>
<span class="fc" id="L369">			} catch (NoSuchFieldException e) {</span>
<span class="fc" id="L370">				clazz = clazz.getSuperclass();</span>
<span class="fc" id="L371">			}</span>
		}
<span class="fc bfc" id="L373" title="All 2 branches covered.">		if (field == null) {</span>
<span class="fc" id="L374">			LOG.warn(&quot;A field could not be found for attribute '{}[{}]'&quot;,</span>
					pojoClass, attributeName);
		}
<span class="fc" id="L377">		return field;</span>
	}

	/**
	 * It returns an value for a {@link Field} matching the attribute
	 * name or null if a field was not found.
	 *
	 * @param &lt;T&gt;
	 *            The type of field to be returned
	 * @param pojo
	 *            The class supposed to contain the field
	 * @param attributeName
	 *            The field name
	 *
	 * @return an instance of {@link Field} matching the attribute name or
	 *         null if a field was not found.
	 */
	public static &lt;T&gt; T getFieldValue(Object pojo, String attributeName) {
<span class="fc" id="L395">		T retValue = null;</span>

		try {
<span class="fc" id="L398">			Field field = PodamUtils.getField(pojo.getClass(), attributeName);</span>

<span class="fc bfc" id="L400" title="All 2 branches covered.">			if (field != null) {</span>

				// It allows to invoke Field.get on private fields
<span class="fc" id="L403">				field.setAccessible(true);</span>

				@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L406">				T t = (T) field.get(pojo);</span>
<span class="fc" id="L407">				retValue = t;</span>
<span class="fc" id="L408">			} else {</span>

<span class="fc" id="L410">				LOG.info(&quot;The field {}[{}] didn't exist.&quot;, pojo.getClass(), attributeName);</span>
			}

<span class="nc" id="L413">		} catch (Exception e) {</span>

<span class="nc" id="L415">			LOG.warn(&quot;We couldn't get default value for {}[{}]&quot;,</span>
<span class="nc" id="L416">					pojo.getClass(), attributeName, e);</span>
<span class="fc" id="L417">		}</span>

<span class="fc" id="L419">		return retValue;</span>
	}

	/**
	 * Given the attribute and setter it combines annotations from them
	 * or an empty collection if no custom annotations were found
	 *
	 * @param attribute
	 *            The class attribute
	 * @param setter
	 *            The class attribute'sÂ setter
	 * @return all annotations for the attribute
	 */
	public static List&lt;Annotation&gt; getAttributeAnnotations(final Field attribute,
			final Method setter) {

<span class="fc bfc" id="L435" title="All 2 branches covered.">		Annotation[] annotations = (attribute != null ? attribute.getAnnotations() : null);</span>

		List&lt;Annotation&gt; retValue;
<span class="fc bfc" id="L438" title="All 4 branches covered.">		if (annotations != null &amp;&amp; annotations.length != 0) {</span>
<span class="fc" id="L439">			retValue = Arrays.asList(annotations);</span>
		} else {
<span class="fc" id="L441">			retValue = new ArrayList&lt;Annotation&gt;();</span>
		}
<span class="fc bfc" id="L443" title="All 2 branches covered.">		for (Annotation annotation : setter.getParameterAnnotations()[0]) {</span>
<span class="fc" id="L444">			retValue.add(annotation);</span>
		}

<span class="fc" id="L447">		return retValue;</span>
	}

	/**
	 * Generates random character from set valid for identifiers in Java language
	 *
	 * @return random character suitable for identifier
	 */
	public static Character getNiceCharacter() {

		int randomCharIdx =
<span class="fc" id="L458">				(int) (Math.random() * (NICE_ASCII_CHARACTERS.length - 1) + 0.5);</span>

<span class="fc" id="L460">		return NICE_ASCII_CHARACTERS[randomCharIdx];</span>

	}
	
	/**
	 * It returns a long/Long value between min and max value (included).
	 * 
	 * @param minValue
	 *            The minimum value for the returned value
	 * @param maxValue
	 *            The maximum value for the returned value
	 * @return A long/Long value between min and max value (included).
	 */
	public static long getLongInRange(long minValue, long maxValue) {
<span class="fc" id="L474">		return (long) (minValue + Math.random() * (maxValue - minValue) + 0.5);</span>
	}

	/**
	 * Finds boxed type for a primitive type
	 * 
	 * @param primitiveType
	 *            Primitive type to find boxed type for
	 * @return A boxed type or the same type, if original type was not primitive
	 */
	public static Class&lt;?&gt; primitiveToBoxedType(Class&lt;?&gt; primitiveType) {

<span class="fc bfc" id="L486" title="All 2 branches covered.">		if (int.class.equals(primitiveType)) {</span>
<span class="fc" id="L487">			return Integer.class;</span>
<span class="fc bfc" id="L488" title="All 2 branches covered.">		} else if (double.class.equals(primitiveType)) {</span>
<span class="fc" id="L489">			return Double.class;</span>
<span class="fc bfc" id="L490" title="All 2 branches covered.">		} else if (long.class.equals(primitiveType)) {</span>
<span class="fc" id="L491">			return Long.class;</span>
<span class="fc bfc" id="L492" title="All 2 branches covered.">		} else if (byte.class.equals(primitiveType)) {</span>
<span class="fc" id="L493">			return Byte.class;</span>
<span class="fc bfc" id="L494" title="All 2 branches covered.">		} else if (float.class.equals(primitiveType)) {</span>
<span class="fc" id="L495">			return Float.class;</span>
<span class="pc bpc" id="L496" title="1 of 2 branches missed.">		} else if (char.class.equals(primitiveType)) {</span>
<span class="nc" id="L497">			return Character.class;</span>
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">		} else if (short.class.equals(primitiveType)) {</span>
<span class="fc" id="L499">			return Short.class;</span>
		} else {
<span class="nc" id="L501">			return primitiveType;</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>