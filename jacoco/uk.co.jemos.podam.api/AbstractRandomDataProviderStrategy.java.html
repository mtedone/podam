<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AbstractRandomDataProviderStrategy.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">podam</a> &gt; <a href="index.source.html" class="el_package">uk.co.jemos.podam.api</a> &gt; <span class="el_source">AbstractRandomDataProviderStrategy.java</span></div><h1>AbstractRandomDataProviderStrategy.java</h1><pre class="source lang-java linenums">/**
 *
 */
package uk.co.jemos.podam.api;

import net.jcip.annotations.ThreadSafe;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import uk.co.jemos.podam.common.*;

import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.lang.reflect.Type;
import java.util.*;
import java.util.Map.Entry;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Default abstract implementation of a {@link DataProviderStrategy}
 * &lt;p&gt;
 * This default implementation returns values based on a random generator.
 * Convinient for subclassing and redefining behaviour.
 * &lt;b&gt;Don't use this implementation if you seek deterministic values&lt;/b&gt;
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * All values returned by this implementation are &lt;b&gt;different from zero&lt;/b&gt;.
 * &lt;/p&gt;
 *
 * @author mtedone
 *
 * @since 1.0.0
 *
 */
@ThreadSafe
public abstract class AbstractRandomDataProviderStrategy implements RandomDataProviderStrategy {

	// -------------------&gt;&gt; Constants

	/** Application logger */
<span class="fc" id="L45">	private static final Logger LOG = LoggerFactory</span>
<span class="fc" id="L46">			.getLogger(AbstractRandomDataProviderStrategy.class);</span>

	/** A RANDOM generator */
<span class="fc" id="L49">	private static final Random RANDOM = new Random(System.currentTimeMillis());</span>

	/**
	 * How many times it is allowed to PODAM to create an instance of the same
	 * class in a recursive hierarchy
	 */
	public static final int MAX_DEPTH = 1;

	/** The max stack trace depth. */
<span class="fc" id="L58">	private final AtomicInteger maxDepth = new AtomicInteger(MAX_DEPTH);</span>

	/** The number of collection elements. */
<span class="fc" id="L61">	private final AtomicInteger nbrOfCollectionElements = new AtomicInteger();</span>

	/** Flag to enable/disable the memoization setting. */
<span class="fc" id="L64">	private final AtomicBoolean isMemoizationEnabled = new AtomicBoolean();</span>

	/**
	 * A map to keep one object for each class. If memoization is enabled, the
	 * factory will use this table to avoid creating objects of the same class
	 * multiple times.
	 */
<span class="fc" id="L71">	private final ConcurrentMap&lt;Class&lt;?&gt;, ConcurrentMap&lt;Type[], Object&gt;&gt; memoizationTable = new ConcurrentHashMap&lt;Class&lt;?&gt;, ConcurrentMap&lt;Type[], Object&gt;&gt;();</span>

	/**
	 * A list of user-submitted specific implementations for interfaces and
	 * abstract classes
	 */
<span class="fc" id="L77">	private final ConcurrentMap&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; specificTypes = new ConcurrentHashMap&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;();</span>

	/**
	 * Mapping between annotations and attribute strategies
	 */
<span class="fc" id="L82">	private final ConcurrentMap&lt;Class&lt;? extends Annotation&gt;, Class&lt;AttributeStrategy&lt;?&gt;&gt;&gt; attributeStrategies</span>
			= new ConcurrentHashMap&lt;Class&lt;? extends Annotation&gt;, Class&lt;AttributeStrategy&lt;?&gt;&gt;&gt;();

	/** The constructor comparator */
<span class="fc" id="L86">	private AbstractConstructorComparator constructorHeavyComparator =</span>
			ConstructorHeavyFirstComparator.INSTANCE;

	/** The constructor comparator */
<span class="fc" id="L90">	private AbstractConstructorComparator constructorLightComparator =</span>
			ConstructorLightFirstComparator.INSTANCE;

	/** The constructor comparator */
<span class="fc" id="L94">	private AbstractMethodComparator methodHeavyComparator</span>
			= MethodHeavyFirstComparator.INSTANCE;

	/** The constructor comparator */
<span class="fc" id="L98">	private AbstractMethodComparator methodLightComparator</span>
			= MethodLightFirstComparator.INSTANCE;

	// -------------------&gt;&gt; Instance / Static variables

	// -------------------&gt;&gt; Constructors

	/**
	 * Implementation of the Singleton pattern
	 */
	public AbstractRandomDataProviderStrategy() {
<span class="fc" id="L109">		this(PodamConstants.DEFAULT_NBR_COLLECTION_ELEMENTS);</span>
<span class="fc" id="L110">	}</span>

<span class="fc" id="L112">	public AbstractRandomDataProviderStrategy(int nbrOfCollectionElements) {</span>
<span class="fc" id="L113">		this.nbrOfCollectionElements.set(nbrOfCollectionElements);</span>
<span class="fc" id="L114">	}</span>

	// -------------------&gt;&gt; Public methods

	/**
	 * {@inheritDoc}
	 */

	@Override
	public Boolean getBoolean(AttributeMetadata attributeMetadata) {

<span class="fc" id="L125">		log(attributeMetadata);</span>
<span class="fc" id="L126">		return Boolean.TRUE;</span>
	}

	/**
	 * {@inheritDoc}
	 */

	@Override
	public Byte getByte(AttributeMetadata attributeMetadata) {

<span class="fc" id="L136">		log(attributeMetadata);</span>
		byte nextByte;
		do {
<span class="fc" id="L139">			nextByte = (byte) RANDOM.nextInt(Byte.MAX_VALUE);</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">		} while (nextByte == 0);</span>
<span class="fc" id="L141">		return nextByte;</span>
	}

	/**
	 * {@inheritDoc}
	 */

	@Override
	public Byte getByteInRange(byte minValue, byte maxValue,
			AttributeMetadata attributeMetadata) {

<span class="fc" id="L152">		log(attributeMetadata);</span>
<span class="fc" id="L153">		return (byte) (minValue + Math.random() * (maxValue - minValue) + 0.5);</span>
	}

	/**
	 * {@inheritDoc}
	 */

	@Override
	public Character getCharacter(AttributeMetadata attributeMetadata) {

<span class="fc" id="L163">		log(attributeMetadata);</span>
<span class="fc" id="L164">		return PodamUtils.getNiceCharacter();</span>

	}

	/**
	 * {@inheritDoc}
	 */

	@Override
	public Character getCharacterInRange(char minValue, char maxValue,
			AttributeMetadata attributeMetadata) {

<span class="fc" id="L176">		log(attributeMetadata);</span>
<span class="fc" id="L177">		return (char) (minValue + Math.random() * (maxValue - minValue) + 0.5);</span>
	}

	/**
	 * {@inheritDoc}
	 */

	@Override
	public Double getDouble(AttributeMetadata attributeMetadata) {

<span class="fc" id="L187">		log(attributeMetadata);</span>
		double retValue;
		do {
<span class="fc" id="L190">			retValue = RANDOM.nextDouble();</span>
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">		} while (retValue == 0.0);</span>
<span class="fc" id="L192">		return retValue;</span>
	}

	/**
	 * {@inheritDoc}
	 */

	@Override
	public Double getDoubleInRange(double minValue, double maxValue,
			AttributeMetadata attributeMetadata) {

<span class="fc" id="L203">		log(attributeMetadata);</span>
		// This can happen. It's a way to specify a precise value
<span class="fc bfc" id="L205" title="All 2 branches covered.">		if (minValue == maxValue) {</span>
<span class="fc" id="L206">			return minValue;</span>
		}
		double retValue;
		do {
<span class="fc" id="L210">			retValue = minValue + Math.random() * (maxValue - minValue + 1);</span>
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">		} while (retValue &gt; maxValue);</span>
<span class="fc" id="L212">		return retValue;</span>
	}

	/**
	 * {@inheritDoc}
	 */

	@Override
	public Float getFloat(AttributeMetadata attributeMetadata) {

<span class="fc" id="L222">		log(attributeMetadata);</span>
		float retValue;
		do {
<span class="fc" id="L225">			retValue = RANDOM.nextFloat();</span>
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">		} while (retValue == 0.0f);</span>
<span class="fc" id="L227">		return retValue;</span>
	}

	/**
	 * {@inheritDoc}
	 */

	@Override
	public Float getFloatInRange(float minValue, float maxValue,
			AttributeMetadata attributeMetadata) {

<span class="fc" id="L238">		log(attributeMetadata);</span>
		// This can happen. It's a way to specify a precise value
<span class="fc bfc" id="L240" title="All 2 branches covered.">		if (minValue == maxValue) {</span>
<span class="fc" id="L241">			return minValue;</span>
		}
		float retValue;
		do {
<span class="fc" id="L245">			retValue = (float) (minValue</span>
<span class="fc" id="L246">					+ Math.random() * (maxValue - minValue + 1));</span>
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">		} while (retValue &gt; maxValue);</span>
<span class="fc" id="L248">		return retValue;</span>
	}

	/**
	 * {@inheritDoc}
	 */

	@Override
	public Integer getInteger(AttributeMetadata attributeMetadata) {

<span class="fc" id="L258">		log(attributeMetadata);</span>
		Integer retValue;
		do {
<span class="fc" id="L261">			retValue = RANDOM.nextInt();</span>
<span class="pc bpc" id="L262" title="1 of 2 branches missed.">		} while (retValue.intValue() == 0);</span>
<span class="fc" id="L263">		return retValue;</span>
	}

	/**
	 * {@inheritDoc}
	 */

	@Override
	public int getIntegerInRange(int minValue, int maxValue,
			AttributeMetadata attributeMetadata) {

<span class="fc" id="L274">		log(attributeMetadata);</span>
<span class="fc" id="L275">		return (int) (minValue + Math.random() * (maxValue - minValue) + 0.5);</span>
	}

	/**
	 * This implementation returns the current time in milliseconds.
	 * &lt;p&gt;
	 * This can be useful for Date-like constructors which accept a long as
	 * argument. A complete random number would cause the instantiation of such
	 * classes to fail on a non-deterministic basis, e.g. when the random long
	 * would not be an acceptable value for, say, a YEAR field.
	 * &lt;/p&gt;
	 * {@inheritDoc}
	 */

	@Override
	public Long getLong(AttributeMetadata attributeMetadata) {

<span class="fc" id="L292">		log(attributeMetadata);</span>
<span class="fc" id="L293">		return System.nanoTime();</span>
	}

	/**
	 * {@inheritDoc}
	 */

	@Override
	public Long getLongInRange(long minValue, long maxValue,
			AttributeMetadata attributeMetadata) {

<span class="fc" id="L304">		log(attributeMetadata);</span>
<span class="fc" id="L305">		return PodamUtils.getLongInRange(minValue, maxValue);</span>
	}

	/**
	 * {@inheritDoc}
	 */

	@Override
	public Short getShort(AttributeMetadata attributeMetadata) {

<span class="fc" id="L315">		log(attributeMetadata);</span>
		short retValue;
		do {
<span class="fc" id="L318">			retValue = (short) RANDOM.nextInt(Byte.MAX_VALUE);</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">		} while (retValue == 0);</span>
<span class="fc" id="L320">		return retValue;</span>
	}

	/**
	 * {@inheritDoc}
	 */

	@Override
	public Short getShortInRange(short minValue, short maxValue,
			AttributeMetadata attributeMetadata) {

<span class="fc" id="L331">		log(attributeMetadata);</span>
<span class="fc" id="L332">		return (short) (minValue + Math.random() * (maxValue - minValue) + 0.5);</span>
	}

	/**
	 * {@inheritDoc}
	 */

	@Override
	public String getStringValue(AttributeMetadata attributeMetadata) {

<span class="fc" id="L342">		log(attributeMetadata);</span>
<span class="fc" id="L343">		return getStringOfLength(PodamConstants.STR_DEFAULT_LENGTH,</span>
				attributeMetadata);
	}

	/**
	 * {@inheritDoc}
	 */

	@Override
	public String getStringOfLength(int length,
			AttributeMetadata attributeMetadata) {

<span class="fc" id="L355">		log(attributeMetadata);</span>
<span class="fc" id="L356">		StringBuilder buff = new StringBuilder();</span>

<span class="fc bfc" id="L358" title="All 2 branches covered.">		while (buff.length() &lt; length) {</span>
<span class="fc" id="L359">			buff.append(getCharacter(attributeMetadata));</span>
		}

<span class="fc" id="L362">		return buff.toString();</span>

	}

	// -------------------&gt;&gt; Getters / Setters

	/**
	 * {@inheritDoc}
	 */
	@Override
	public int getNumberOfCollectionElements(Class&lt;?&gt; type) {
<span class="fc" id="L373">		return nbrOfCollectionElements.get();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setDefaultNumberOfCollectionElements(int newNumberOfCollectionElements) {
<span class="fc" id="L381">		nbrOfCollectionElements.set(newNumberOfCollectionElements);</span>
<span class="fc" id="L382">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public int getMaxDepth(Class&lt;?&gt; type) {
<span class="fc" id="L389">		return maxDepth.get();</span>
	}

	/**
	 * Sets the new max stack trace depth.
	 *
	 * @param newMaxDepth
	 *            The new max stack trace depth.
	 */
	public void setMaxDepth(int newMaxDepth) {
<span class="nc" id="L399">		maxDepth.set(newMaxDepth);</span>
<span class="nc" id="L400">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean isMemoizationEnabled() {
<span class="fc" id="L407">		return isMemoizationEnabled.get();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setMemoization(boolean isMemoizationEnabled) {
<span class="fc" id="L415">		this.isMemoizationEnabled.set(isMemoizationEnabled);</span>
<span class="fc" id="L416">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Object getMemoizedObject(AttributeMetadata attributeMetadata) {

<span class="fc bfc" id="L424" title="All 2 branches covered.">		if (isMemoizationEnabled.get()) {</span>
			/* No memoization for arrays, collections and maps */
<span class="fc" id="L426">			Class&lt;?&gt; pojoClass = attributeMetadata.getPojoClass();</span>
<span class="fc bfc" id="L427" title="All 2 branches covered.">			if (pojoClass == null ||</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">					(!pojoClass.isArray() &amp;&amp;</span>
<span class="fc bfc" id="L429" title="All 2 branches covered.">					!Collection.class.isAssignableFrom(pojoClass) &amp;&amp;</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">					!Map.class.isAssignableFrom(pojoClass))) {</span>

<span class="fc" id="L432">				ConcurrentMap&lt;Type[], Object&gt; map = memoizationTable.get(attributeMetadata.getAttributeType());</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">				if (map != null) {</span>
<span class="fc bfc" id="L434" title="All 2 branches covered.">					for (Entry&lt;Type[], Object&gt; entry : map.entrySet()) {</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">						if (Arrays.equals(entry.getKey(), attributeMetadata.getAttrGenericArgs())) {</span>
<span class="fc" id="L436">							return entry.getValue();</span>
						}
<span class="fc" id="L438">					}</span>
				}
			}
		}
<span class="fc" id="L442">		return null;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void cacheMemoizedObject(AttributeMetadata attributeMetadata,
			Object instance) {

<span class="fc bfc" id="L452" title="All 2 branches covered.">		if (isMemoizationEnabled.get()) {</span>
<span class="fc" id="L453">			ConcurrentMap&lt;Type[], Object&gt; map = memoizationTable.get(attributeMetadata.getAttributeType());</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">			if (map == null) {</span>
<span class="fc" id="L455">				map = new ConcurrentHashMap&lt;Type[], Object&gt;();</span>

<span class="fc" id="L457">				memoizationTable.putIfAbsent(attributeMetadata.getAttributeType(), map);</span>
			}
<span class="fc" id="L459">			map.putIfAbsent(attributeMetadata.getAttrGenericArgs(), instance);</span>
		}
<span class="fc" id="L461">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void clearMemoizationCache() {

<span class="fc" id="L469">		memoizationTable.clear();</span>


<span class="fc" id="L472">	}</span>

	/**
	 * Rearranges POJO's constructors in order they will be tried to produce the
	 * POJO. Default strategy consist of putting constructors with less
	 * parameters to be tried first.
	 *
	 * @param constructors
	 *            Array of POJO's constructors
	 * @param order
	 *            {@link uk.co.jemos.podam.api.DataProviderStrategy.Order} how to sort constructors
	 */
	@Override
	public void sort(Constructor&lt;?&gt;[] constructors, Order order) {
		AbstractConstructorComparator constructorComparator;
<span class="pc bfc" id="L487" title="All 2 branches covered.">		switch(order) {</span>
		case HEAVY_FIRST:
<span class="fc" id="L489">			constructorComparator = constructorHeavyComparator;</span>
<span class="fc" id="L490">			break;</span>
		default:
<span class="fc" id="L492">			constructorComparator = constructorLightComparator;</span>
			break;
		}
<span class="fc" id="L495">		Arrays.sort(constructors, constructorComparator);</span>
<span class="fc" id="L496">	}</span>

	/**
	 * Rearranges POJO's methods in order they will be tried to produce the
	 * POJO. Default strategy consist of putting methods with more
	 * parameters to be tried first.
	 *
	 * @param methods
	 *            Array of POJO's methods
	 * @param order
	 *            {@link uk.co.jemos.podam.api.DataProviderStrategy.Order} how to sort constructors
	 */
	@Override
	public void sort(Method[] methods, Order order) {
		AbstractMethodComparator methodComparator;
<span class="fc bfc" id="L511" title="All 2 branches covered.">		switch(order) {</span>
		case HEAVY_FIRST:
<span class="fc" id="L513">			methodComparator = methodHeavyComparator;</span>
<span class="fc" id="L514">			break;</span>
		default:
<span class="fc" id="L516">			methodComparator = methodLightComparator;</span>
			break;
		}
<span class="fc" id="L519">		Arrays.sort(methods, methodComparator);</span>
<span class="fc" id="L520">	}</span>

	/**
	 * Bind an interface/abstract class to a specific implementation. If the
	 * strategy previously contained a binding for the interface/abstract class,
	 * the old value will not be replaced by the new value. If you want to force the
	 * value replacement, invoke removeSpecific before invoking this method.
	 * If you want to implement more sophisticated binding strategy, override this class.
	 *
	 * @param &lt;T&gt; return type
	 * @param abstractClass
	 *            the interface/abstract class to bind
	 * @param specificClass
	 *            the specific class implementing or extending
	 *            {@code abstractClass}.
	 * @return itself
	 */
	@Override
	public &lt;T&gt; RandomDataProviderStrategy addSpecific(
			final Class&lt;T&gt; abstractClass, final Class&lt;? extends T&gt; specificClass) {

<span class="fc" id="L541">		specificTypes.putIfAbsent(abstractClass, specificClass);</span>

<span class="fc" id="L543">		return this;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public &lt;T&gt; RandomDataProviderStrategy removeSpecific(
			final Class&lt;T&gt; abstractClass) {

<span class="fc" id="L553">		specificTypes.remove(abstractClass);</span>
<span class="fc" id="L554">		return this;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public &lt;T&gt; Class&lt;? extends T&gt; getSpecificClass(
			Class&lt;T&gt; nonInstantiatableClass) {

<span class="fc" id="L564">		Class&lt;? extends T&gt; found = (Class&lt;? extends T&gt;) specificTypes</span>
<span class="fc" id="L565">				.get(nonInstantiatableClass);</span>
<span class="fc bfc" id="L566" title="All 2 branches covered.">		if (found == null) {</span>
<span class="fc" id="L567">			found = nonInstantiatableClass;</span>
		}
<span class="fc" id="L569">		return found;</span>

	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public RandomDataProviderStrategy addAttributeStrategy(
			final Class&lt;? extends Annotation&gt; annotationClass,
			final Class&lt;AttributeStrategy&lt;?&gt;&gt; strategyClass) {

<span class="fc" id="L581">		attributeStrategies.putIfAbsent(annotationClass, strategyClass);</span>

<span class="fc" id="L583">		return this;</span>
	}

	/**
	 * Remove binding of an annotation to attribute strategy
	 *
	 * @param annotationClass
	 *            the annotation class to remove binding
	 * @return itself
	 */
	@Override
	public RandomDataProviderStrategy removeAttributeStrategy(
			final Class&lt;? extends Annotation&gt; annotationClass) {

<span class="fc" id="L597">		attributeStrategies.remove(annotationClass);</span>

<span class="fc" id="L599">		return this;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Class&lt;AttributeStrategy&lt;?&gt;&gt; getStrategyForAnnotation(
			final Class&lt;? extends Annotation&gt; annotationClass) {

<span class="fc" id="L609">		return attributeStrategies.get(annotationClass);</span>

	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public AbstractConstructorComparator getConstructorLightComparator() {
<span class="fc" id="L618">		return constructorLightComparator;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setConstructorLightComparator(AbstractConstructorComparator constructorLightComparator) {
<span class="fc" id="L626">		this.constructorLightComparator = constructorLightComparator;</span>
<span class="fc" id="L627">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public AbstractConstructorComparator getConstructorHeavyComparator() {
<span class="fc" id="L634">		return constructorHeavyComparator;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setConstructorHeavyComparator(AbstractConstructorComparator constructorHeavyComparator) {
<span class="fc" id="L642">		this.constructorHeavyComparator = constructorHeavyComparator;</span>
<span class="fc" id="L643">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public AbstractMethodComparator getMethodLightComparator() {
<span class="fc" id="L650">		return methodLightComparator;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setMethodLightComparator(AbstractMethodComparator methodLightComparator) {
<span class="fc" id="L658">		this.methodLightComparator = methodLightComparator;</span>
<span class="fc" id="L659">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public AbstractMethodComparator getMethodHeavyComparator() {
<span class="fc" id="L666">		return methodHeavyComparator;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setMethodHeavyComparator(AbstractMethodComparator methodHeavyComparator) {
<span class="fc" id="L674">		this.methodHeavyComparator = methodHeavyComparator;</span>
<span class="fc" id="L675">	}</span>

	// -------------------&gt;&gt; Private methods

	private void log(AttributeMetadata attributeMetadata) {
<span class="fc" id="L680">		LOG.trace(&quot;Providing data for attribute {}.{}&quot;,</span>
<span class="fc" id="L681">				attributeMetadata.getPojoClass().getName(),</span>
<span class="fc bfc" id="L682" title="All 2 branches covered.">				attributeMetadata.getAttributeName() != null ? attributeMetadata.getAttributeName() : &quot;&quot;);</span>
<span class="fc" id="L683">	}</span>

	// -------------------&gt;&gt; equals() / hashcode() / toString()

	// -------------------&gt;&gt; Inner classes

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>